# ES6+

## Block Scope

함수스코프란 함수에 의해서 생기는 범위, 변수의 유효범위

블락스코프란 블락에 의해 생기는 유효범위로 {} 에 의해서 생기는 유효 범위다.

let const에 대해서만 동작

if, for, while, switch-case문
문 자체가 하나의 블록스코프가 된다.

## Hoisting

호이스팅이란 선언문을 유효범위의 최상단으로 끌어올리는 행위이다. **선언과 할당의 분리**라고 할수 있다.

```jsx
if (true) {
  var name = "hoistion";
}
console.log(name);
f();
function f() {
  console.log("hi");
}
```

- hoisting으로 인해 아래의 코드로 해석이됌.

```jsx
/*선언 */
var name; //선언문이 유효범위 최상단으로 끌어올려짐
function f() {
  console.log("hi");
}

/* 실행 */
if (true) {
  name = "yuddomack"; // 할당
}
console.log(name);
f();
```

### 함수 호이스팅

```jsx
sayName();
function sayName() {
  console.log("hoisting"); //함수 선언식
}
----------------------------------------------sayName2();
var sayName = function () {
  console.log("hoisting");
};
```

========>

```jsx
function sayName(){
    console.log('hoistion')
}
sayName();
----------------------------------------------
var sayName2;
sayName2();
sayName2 = function(){
    console.log('hoisting')
}
```

함수 표현식인 경우 var sayName2는 변수이기 때문에 선언과 할당의 분리가 발생해 에러가 발생하게 된다.

### 우선순위

호이스팅의 우선순위를 말하면 변수 할당이 함수선언보다 우선순위이고, 함수선언이 변수 선언보다 우선 순위이다.

### let, const

```jsx
console.log(a); // ReferenceError: a is not defined
let a = 10;
```

블록스코프에서 동작하는 let, const 선언문일 경우 참조 에러가 발생한다.

호이스팅이 일어나지 않는게 아니라, 초기화 되기전까지 **TDZ: Temporal Dead Zone**에 머물게 구현되어있다.

- TDZ는 변수가 할당을 얻기 전까지 잠시 죽어있는 공간이라 생각할 수 있다.

con

## this
